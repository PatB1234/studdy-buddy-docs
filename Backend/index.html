
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="..">
      
      
        <link rel="next" href="../Core%20Functions/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.15">
    
    
      
        <title>Backend - StuddyBuddy Docs</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.342714a4.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#data-structures" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="StuddyBuddy Docs" class="md-header__button md-logo" aria-label="StuddyBuddy Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            StuddyBuddy Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Backend
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="StuddyBuddy Docs" class="md-nav__button md-logo" aria-label="StuddyBuddy Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    StuddyBuddy Docs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Backend
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Backend
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#data-structures" class="md-nav__link">
    <span class="md-ellipsis">
      Data Structures
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#encryption" class="md-nav__link">
    <span class="md-ellipsis">
      Encryption
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tokens" class="md-nav__link">
    <span class="md-ellipsis">
      Tokens
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#storing-user-files" class="md-nav__link">
    <span class="md-ellipsis">
      Storing user files
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Storing user files">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#volatile-data" class="md-nav__link">
    <span class="md-ellipsis">
      Volatile Data
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Volatile Data">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#current-notes" class="md-nav__link">
    <span class="md-ellipsis">
      Current Notes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#caching" class="md-nav__link">
    <span class="md-ellipsis">
      Caching
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#non-volatile-data" class="md-nav__link">
    <span class="md-ellipsis">
      Non-volatile data
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Non-volatile data">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#notes" class="md-nav__link">
    <span class="md-ellipsis">
      Notes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#login-data" class="md-nav__link">
    <span class="md-ellipsis">
      Login Data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tokens_1" class="md-nav__link">
    <span class="md-ellipsis">
      Tokens
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Core%20Functions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Core Functions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Frontend/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Frontend
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Improvements/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Improvements
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Learning/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Learning
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#data-structures" class="md-nav__link">
    <span class="md-ellipsis">
      Data Structures
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#encryption" class="md-nav__link">
    <span class="md-ellipsis">
      Encryption
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tokens" class="md-nav__link">
    <span class="md-ellipsis">
      Tokens
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#storing-user-files" class="md-nav__link">
    <span class="md-ellipsis">
      Storing user files
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Storing user files">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#volatile-data" class="md-nav__link">
    <span class="md-ellipsis">
      Volatile Data
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Volatile Data">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#current-notes" class="md-nav__link">
    <span class="md-ellipsis">
      Current Notes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#caching" class="md-nav__link">
    <span class="md-ellipsis">
      Caching
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#non-volatile-data" class="md-nav__link">
    <span class="md-ellipsis">
      Non-volatile data
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Non-volatile data">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#notes" class="md-nav__link">
    <span class="md-ellipsis">
      Notes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#login-data" class="md-nav__link">
    <span class="md-ellipsis">
      Login Data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tokens_1" class="md-nav__link">
    <span class="md-ellipsis">
      Tokens
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<p>The backend stores data in a typical SQL-based database. For python, we used <a href="https://docs.python.org/3/library/sqlite3.html">sqlite3</a>. This is a lightweight, high-speed and efficient database built for small-medium scale applications such as mine. As I am paying for the server out of pocket, efficient use of storage allocation was a necessity. SQLite fulfilled these requirements and did not deprive me of any modern features to make my code cleaner.</p>
<p>To run the application, we used an ASGI server (Asynchronous server gateway interface) to run the API; specifically we used <a href="https://www.uvicorn.org/">uvicorn</a>. Again, it is lightweight, efficient and can handle asynchronous method calls to allow for an overall faster user experience.</p>
<h2 id="data-structures">Data Structures</h2>
<p>All of the data sent from the frontend is sent in the form of JSON data. To allow our backend to interpret this, we used custom BaseModels for each POST &amp; GET call. For example, if our frontend called a login function such as:</p>
<pre><code>this.http.post(this.URL + &quot;/check_student_login&quot;, {email: &quot;example@example.com&quot;, username: &quot;example&quot;, password: &quot;example&quot;}).subscribe((res: any) =&gt; {
</code></pre>
<p>Where <code>email</code>, <code>username</code> and <code>password</code> are the JSON parameters. As a result our backend model would look like:</p>
<pre><code>from pydantic import BaseModel # Module to create the models
class PostLoginCheckStudentModel(BaseModel):

    email: str  
    username: str
    password: str
</code></pre>
<p>And the API would receive the call like so:</p>
<pre><code>@app.post(&quot;/api/check_student_login&quot;)
async def check_student_login_post(user: PostLoginCheckStudentModel):

  return check_student_login(user.email, user.password) # Calls a function on the backend
</code></pre>
<p>These Data Structures are repeated throughout the API and are paramount to our data manipulation methods.</p>
<h2 id="encryption">Encryption</h2>
<p>Firstly, all passwords are encrypted before being stored in the backend. They are encrypted using Passlib's <code>CryptContext</code> module with 'bcrypt' as the schema. The password is encrypted with the following code:</p>
<pre><code>from pydantic import BaseModel # Import module
pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;) # Identify the schema used 
def hash_password(password): # Take a plaintext password &amp; convert it to ciphertext

    return pwd_context.hash(password)
</code></pre>
<p>This will encrypt our password. It is extremely secure as each password is non-reversible. This results in the same input string having a variable output hash as the starting 'salt' used by the algorithm will be different. For example, an input password of <code>1234</code> could result in: <br/>
- $2b$12$zProG7RawgHpdXZ9RfxYZ.pcwZy4N29C6mRzBb8yAFvoHc5TSSyZC <br/>
- $2b$12$0DPNbWZDAX5fJl4pyBHnIuWiLk.2w/rxU/MnuKFznmjouUMjFxW5. <br/>
- $2b$12$U6PDFiGrqooLxsnHJ7X9gehpzH3tLiI./BH8oj3HejMSyZvGHPneC <br/>
- $2b$12$YJK4L0S8pcFKokWUYqf1VuDtjxy.KptvvBN9VTJIvTPTuwc36KwAe <br/>
- $2b$12$MWwHq8PHskJqF2EoGOI60..J92SVyjD5FHVc4Ugbv7ZnD10Wso6yO <br/>
- $2b$12$r5qvt.4ik//TSFaVWxWZ3uFGdmUXJL35.FXeeb2uDiWSQSZYQWv0i <br/>
With there being a large number of potential passwords based on the starting 'salt'.</p>
<p>To verify the value of our password, we do not reverse the hash. This is because reversing the hash is impossible. Instead, we use an inbuilt function that compares the plain-text to the hashed cipher-text. This functionality is used when authenticating a user during login and is done as such:</p>
<pre><code>from pydantic import BaseModel # Import module
pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;) # Identify the schema used 
def verify_password(unhashed, hashed): 

    return pwd_context.verify(unhashed, hashed) # Returns a boolean
</code></pre>
<p>This function compares the original 'salt' and 'work factor' (Number of encryption iterations) and calculates whether the hash could have been derived from this input. If the algorithm deems it possible, then a boolean value of <code>True</code> is returned, otherwise the function returns <code>False</code>.</p>
<h2 id="tokens">Tokens</h2>
<p>When the frontend needs to make any request to the backend, it needs to provide a token. This token is valid for 7 days and stores the <code>name</code>, <code>email</code> and <code>id</code> of the user (student) that is currently logged in. <br/></p>
<p>When a user attempts to login, the details they input are checked against the database. If the email and password inputted align with an email and password from the database, a token is created and sent to the frontend. The token is created using the code:</p>
<pre><code>def get_user_token(student: Student):
    to_encode = {
        'details' : {'name': student.name, 'email': student.email, 'id': student.id},
        'expiry' : str(datetime.utcnow() + timedelta(minutes = ACCESS_TOKEN_EXPIRE_MINUTES))

    }
    return jwt.encode(to_encode, SECRET_KEY, algorithm = ALGORITHM)
</code></pre>
<p>Where <code>SECRET_KEY</code> is a 256-bit custom code that is used for encryption and the algorithm is HS256. This token is then stored in the user's browser data. As a result of this, the user will not have to log in to the website on every occurrence of accessing the website. The frontend injects this token into every request as shown by the code: </p>
<pre><code>@Injectable()
export class CookieInterceptor implements HttpInterceptor {

    private platformId = inject(PLATFORM_ID);
    intercept(request: HttpRequest&lt;unknown&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;unknown&gt;&gt; { // Intercepts an incoming request

        let token: string | undefined;
        if (isPlatformBrowser(this.platformId)) {
        token = document.cookie.split(&quot;; &quot;).find((row) =&gt; row.startsWith(&quot;token=&quot;))?.split(&quot;=&quot;)[1];
    } // Extracts the token from the web-browser

        const modifiedRequest = request.clone({
            withCredentials: true,
            setHeaders: token ? { 'token': token } : {} // Adds the token to the request    
        });

    return next.handle(modifiedRequest); // Sends the request to the API
    }

}
</code></pre>
<p>Once the backend receives this token, it then verifies the token in every single function before even executing the intended request of the method call. This is done through the code: </p>
<pre><code>@app.post(&quot;/api/function_name&quot;)
async def function_name(request: Request):
    token_res = validate_student(request.headers.get('token')) # Runs a backend function to validate the token by extracting the user details and checking the expiry of the token
    if token_res == False:

        return JSONResponse(status_code=401, content={&quot;message&quot;: &quot;Invalid token&quot;}) # Prevents any functions if the token is invalid
    else:

        # Execute the intended code here
</code></pre>
<p>To validate the token, the code firsts calls the function <code>validate_student()</code>:</p>
<pre><code>def validate_student(token):
    try:

        res = get_student_from_token(token)
        if res == &quot;Token Expired&quot;: # Checks if the token is past its expiry date

            return False
        else:

            # Returns details in the form of a list
            return [res['name'], res['email'], res['id']]
            # If the token is invalid, return False
    except InvalidTokenError: 

        return False

    # If the token cannot be decoded, return False

    except InvalidSignatureError: # Checks if the user has tried to use token injection, resulting in an invalid token

        return False
</code></pre>
<p>To get the <code>res</code> variable, our code initially decodes the token using the <code>get_student_from_token(token: str)</code> function:</p>
<pre><code>def get_student_from_token(token):

    payload = jwt.decode(token, SECRET_KEY, algorithms = [ALGORITHM])
    expiry = payload.get('expiry')
    if datetime.utcnow() &gt;= datetime.strptime(expiry, '%Y-%m-%d %H:%M:%S.%f'): # Compares the expiry date to the current date based on UCT

        return &quot;Token Expired&quot;
    else:

        return payload.get('details') # Returns the details as a dictionary of the name, email and UID
</code></pre>
<p>This means that an expired or invalid token will immediately be rejected but a valid and correct token will be decoded. The app then performs all of its functions based on this data, allowing the app to extract the user's notes based on the <code>OWNER_EMAIL</code> property of each file, ensuring the privacy of user data and maintains the user experience. </p>
<p>If the app returns a <code>401</code> error due to a bad token, the frontend intercepts this error and redirects the user to a login/sign-up page, as shown in the code: </p>
<pre><code>@Injectable()
export class ErrorInterceptor implements HttpInterceptor {
    constructor(private router: Router, private route: ActivatedRoute) {}
    getChildRoute(route: ActivatedRoute): ActivatedRoute {  
        while (route.firstChild) {

            route = route.firstChild;
        }

        return route;
    }

    intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {

        const modifiedRequest = request.clone({ // Clones any incoming requests

            headers: request.headers.set('X-Requested-With', 'XMLHttpRequest'),
            withCredentials: true
        });

        return next.handle(modifiedRequest).pipe( tap(() =&gt; {}, (err: any) =&gt; {


            if (err instanceof HttpErrorResponse) { // Checks if we have received an error

                if (err.status != 401 ) {

                    return;
                }

                this.router.navigate(['/login']); // Prevents the request from going through and redirects to login page instead

            }
        }));

    }

}
</code></pre>
<p>This all ensures that the user can use the app easily, as they do not have to specify their ID when trying to use the app's functions whilst also preventing bad actors from accessing user data.</p>
<p>There is one exception to each API call having a token requirements. This is the <code>cloud_check()</code> function and is used by me to check if the API is responding to API calls. It is a simple <code>get</code> API call: </p>
<pre><code>@app.get(&quot;/api/cloud_check&quot;)
async def cloud_check():

    return True
</code></pre>
<p>And was initially used by my service provider to notify me if my API goes down. This is the only potential vulnerability evident to me, and is more dependent on my provider's (Linode) protection to unauthorised IPv6 &amp; IPv4 calls to the server. When calling the method, it should return the following page:</p>
<p><img alt="Cloud Check" src="https://storage.googleapis.com/studdy-buddy-docs-image-hosting/Cloud%20Check%20API%20Call%20example.png" /></p>
<h1 id="storing-user-files">Storing user files</h1>
<p>When a user uploads a file, it is stored in our backend as a raw .PDF file. These files are not encrypted and are stored as their raw content. Their security is dependent upon the security of our service provider, Linode. The only feasible point of interception is when the file is being transmitted to the Backend from the Frontend.</p>
<p>Before even allowing the data to be uploaded, we first have to verify its size. Gemini AI, like other commerical AIs converts input data and prompts to tokens that it can decode and understand. Similarly, input files are converted to tokens. There is a limit to the number of tokens that the AI can handle. To ensure that the files aren't too large (i.e. too many tokens), we use the <code>count_tokens</code> function of the API. This counts the tokens with the code: </p>
<pre><code>token_no = client.models.count_tokens(model=model_name,contents=client.files.upload(file=file_path, config={'display_name': 'test_data'})).total_tokens
</code></pre>
<p>We then compare it to the limit, returning a boolean value depending on the result.</p>
<p>However, we also have this statement encapsulated in a <code>try...except...</code> loop as if this request fails, then we know that the file is too large so we automatically reject it.</p>
<p>NOTE: Files such as handwritten files have a lower capacity as they require more tokens and often cannot be decoded by the AI. To circumvent this, I am working on implementing a form of Vision AI to convert handwritten text to PDF Format. However, this also has its limitations.</p>
<h2 id="volatile-data">Volatile Data</h2>
<h3 id="current-notes">Current Notes</h3>
<p>The note that the user currently has selected is stored as a python array, as this allows for quick read/write times and this data does not need to be permanent as the user can simply reselect the notes they are using.</p>
<h3 id="caching">Caching</h3>
<p>We also have caching in place. Previously, it would take anywhere from 30s - 2min for the flashcard &amp; question-answer functionality to respond. To avoid this, any generated flashcards are stored in an array. Before generating them, the code checks if flashcards for the given notes already exist. If they do, then those flashcards are returned. If not, flashcards are generated and stored.</p>
<p>Similarly, the code generates 10 questions at a time and stores them in an array relative to the file. When a question is requested, a question is removed from this list and sent. Once the number of cached questions drops below 3, a new set of questions are requested from the AI. This reduces the wait-time for the user and also makes it more cost-effective on my part as I have to pay for fewer requests, albeit there is a larger size per request.</p>
<h2 id="non-volatile-data">Non-volatile data</h2>
<h3 id="notes">Notes</h3>
<p>The notes stored are non-volatile as they are stored as PDF data.</p>
<h3 id="login-data">Login Data</h3>
<p>User information such as their emails, password and UID's are stored in a sqlite3 database on the SSD of our server</p>
<h3 id="tokens_1">Tokens</h3>
<p>Tokens are actually stored on the browser, and sent to the backend on a per-request basis. The Backend simply verifies their validity therefore they are considered non-volatile.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.56ea9cef.min.js"></script>
      
    
  </body>
</html>