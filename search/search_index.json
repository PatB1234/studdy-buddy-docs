{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to StuddyBuddy To visit StuddyBuddy, go to studdybuddy.app . Viewing Click on the tabs above to view the documentation and development process for this app","title":"Welcome to StuddyBuddy"},{"location":"#welcome-to-studdybuddy","text":"To visit StuddyBuddy, go to studdybuddy.app .","title":"Welcome to StuddyBuddy"},{"location":"#viewing","text":"Click on the tabs above to view the documentation and development process for this app","title":"Viewing"},{"location":"Introduction/","text":"StudyBuddy is a unique app developed by Pratyush Bindal from St. Christopher's School of Bahrain, registered under the MIT License. The app is developed from the ground up (with the essential boilerplate(s)) and aims to revolutionise the learning experience for students in my school by incorporating AI Large-Language models into it. StudyBuddy uses user-created notes to aid the student in revising with interactive approaches such as: Automatic AI summarising Flashcards generation Question & Answers quizzes to test your knowledge of the notes The ability to ask questions to a knowledgeable source (the AI) StudyBuddy utilises the new Gemini 2.0-Flash model from google to provide a cost-effective yet intelligent and correct solution. How was it built? Rome wasn't built in a day \u2014 neither was StudyBuddy. This is an ongoing project that I started in September of 2024 when I realised that I needed questions to test my knowledge of my notes for an upcoming exam. From there, I began development of the app alongside my mentor. The app comprises of a few main parts The backend: - Built in python with FastAPI & Uvicorn - Uses sqlite3 for reliable data storage - Encrypts user passwords with bcrypt cryptography to ensure security - Uses the Gemini 2.0-Flash API for AI communication The Frontend: - Uses AngularJS alongside AngularMaterial to provide a responsive, clean and polished website with ease-of-use for the the user User Safety When using new and ever-evolving technologies such as that of AI, safety is a paramount concern. To aid this, AI never accesses, views, or receives any personally identifiable user data. All it gets in the context (User-provided notes) and the prompt (e.g. \"Make me some flashcards\"). Additionally, user data never leaves the server in a non-encrypted form. Any sensitive user info (Name, email, DOB) are all sent via an encrypted, expiring token that can only be decrypted on the user's computer and our server.","title":"Introduction"},{"location":"Introduction/#how-was-it-built","text":"Rome wasn't built in a day \u2014 neither was StudyBuddy. This is an ongoing project that I started in September of 2024 when I realised that I needed questions to test my knowledge of my notes for an upcoming exam. From there, I began development of the app alongside my mentor. The app comprises of a few main parts The backend: - Built in python with FastAPI & Uvicorn - Uses sqlite3 for reliable data storage - Encrypts user passwords with bcrypt cryptography to ensure security - Uses the Gemini 2.0-Flash API for AI communication The Frontend: - Uses AngularJS alongside AngularMaterial to provide a responsive, clean and polished website with ease-of-use for the the user","title":"How was it built?"},{"location":"Introduction/#user-safety","text":"When using new and ever-evolving technologies such as that of AI, safety is a paramount concern. To aid this, AI never accesses, views, or receives any personally identifiable user data. All it gets in the context (User-provided notes) and the prompt (e.g. \"Make me some flashcards\"). Additionally, user data never leaves the server in a non-encrypted form. Any sensitive user info (Name, email, DOB) are all sent via an encrypted, expiring token that can only be decrypted on the user's computer and our server.","title":"User Safety"},{"location":"Developer%20Talk/Backend/","text":"The backend is built using Python 3.12.2 . This is not the latest release at the time, however I found it to be the most stable. I realised that newer version often have stability issues that cause them to crash or have problems that result in some core functionality not working as intended. To avoid this hassle, I chose a version that I have worked with before, as it would have support for all the packages required whilst also remaining stable, ensuring app & user quality. The backend stores data in a typical SQL-based database. For python, we used sqlite3 . This is a lightweight, high-speed and efficient database built for small-medium scale applications such as ours. As I am paying for the server out of pocket, efficient use of storage allocation was a necessity. SQLite fulfilled these requirements and did not deprive me of any modern features to make my code cleaner. To run the application, we used an ASGI (Asynchronous server gateway interface) to run the API, specifically we used uvicorn . Again, it is lightweight, efficient and can handle asynchronous calls to allow for an overall faster user experience. Data Structures All of the data sent from the frontend was sent in the form of JSON. To allow our backend to interpret this, we used custom BaseModels for each POST & GET call. For example, if our frontend called a login function such as: this.http.post(this.URL + \"/check_student_login\", {email: \"example@example.com\", username: \"example\", password: \"example\"}).subscribe((res: any) => { Where, email , username and password are the JSON parameters, then our backend model would look like: from pydantic import BaseModel # Module to create the models class PostLoginCheckStudentModel(BaseModel): email: str username: str password: str And the API would receive the call like so: @app.post(\"/api/check_student_login\") async def check_student_login_post(user: PostLoginCheckStudentModel): return check_student_login(user.email, user.password) # Calls a function on the backend These Data Structures are repeated throughout the API and are paramount to our data manipulation methods. Encryption Firstly, all passwords are encrypted before being stored in the backend. They are encrypted using Passlib's CryptContext module with 'bcrypt' as the schema. The password is encrypted with the following code: from pydantic import BaseModel # Import module pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") # Identify the schema used def hash_password(password): # Take a plaintext password & convert it to ciphertext return pwd_context.hash(password) This will encrypt our password. It is extremely secure as each password is non-reversible. This results in the same input string having a variable output hash as the starting 'salt' used by the algorithm will be different. For example, an input password of 1234 could result in: - $2b$12$zProG7RawgHpdXZ9RfxYZ.pcwZy4N29C6mRzBb8yAFvoHc5TSSyZC - $2b$12$0DPNbWZDAX5fJl4pyBHnIuWiLk.2w/rxU/MnuKFznmjouUMjFxW5. - $2b$12$U6PDFiGrqooLxsnHJ7X9gehpzH3tLiI./BH8oj3HejMSyZvGHPneC - $2b$12$YJK4L0S8pcFKokWUYqf1VuDtjxy.KptvvBN9VTJIvTPTuwc36KwAe - $2b$12$MWwHq8PHskJqF2EoGOI60..J92SVyjD5FHVc4Ugbv7ZnD10Wso6yO - $2b$12$r5qvt.4ik//TSFaVWxWZ3uFGdmUXJL35.FXeeb2uDiWSQSZYQWv0i With there being an almost infinite number of potential passwords based on the starting 'salt'. To verify the value of our password, we do not reverse the hash. This is because reversing the hash is impossible. Instead, we use an inbuilt function that compares the plain-text to the hashed cipher-text. This functionality is used when authenticating a user during login and is done like such: from pydantic import BaseModel # Import module pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") # Identify the schema used def verify_password(unhashed, hashed): return pwd_context.verify(unhashed, hashed) # Returns a boolean This function compares the original 'salt' and 'work factor' (Number of encryption iterations) and calculates whether the hash could have been derived from this input. If the algorithm deems it possible, then a boolean value of True is returned, otherwise the function returns False . Tokens When the frontend needs to make any request to the backend, it needs to provide a token. This token is valid for 7 days and stores the name , email and id of the user (student) that is currently logged in. When a user attempts to login, the details they input are checked against our database. If the email and password inputted align with an email and password from the database, a token is created and sent to the fronted. The token is created using the code: def get_user_token(student: Student): to_encode = { 'details' : {'name': student.name, 'email': student.email, 'id': student.id}, 'expiry' : str(datetime.utcnow() + timedelta(minutes = ACCESS_TOKEN_EXPIRE_MINUTES)) } return jwt.encode(to_encode, SECRET_KEY, algorithm = ALGORITHM) Where SECRET_KEY is a 256-bit custom code that is used for encryption and the algorithm is HS256. This token is then stored in the frontend. As a result of this, the user will not have to log in to the website on every occurrence of accessing the website. The fronted injects this token into every request as shown by the code: @Injectable() export class CookieInterceptor implements HttpInterceptor { private platformId = inject(PLATFORM_ID); intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> { // Intercepts an incoming request let token: string | undefined; if (isPlatformBrowser(this.platformId)) { token = document.cookie.split(\"; \").find((row) => row.startsWith(\"token=\"))?.split(\"=\")[1]; } // Extracts the token from the web-browser const modifiedRequest = request.clone({ withCredentials: true, setHeaders: token ? { 'token': token } : {} // Adds the token to the request }); return next.handle(modifiedRequest); // Sends the request to the API } } Once the backend receives this token, it then verifies it in every single function before even executing the intended request of the method call. This is done through the code: @app.post(\"/api/function_name\") async def post_delete_user(request: Request): token_res = validate_student(request.headers.get('token')) # Runs a backend function to validate the token by extracting the user details and checking the expiry of the token if token_res == False: return JSONResponse(status_code=401, content={\"message\": \"Invalid token\"}) # Prevents any functions if the token is invalid else: # Execute the intended code here To validate the token, the code firsts calls the function validate_student() : def validate_student(token): try: res = get_student_from_token(token) if res == \"Token Expired\": # Checks if the token is past its expiry date return False else: # Returns details in the form of a list return [res['name'], res['email'], res['id']] # If the token is invalid, return False except InvalidTokenError: return False # If the token cannot be decoded, return False except InvalidSignatureError: # Checks if the user has tried to use token injection, resulting in an invalid token return False To get the res variable, our code then decodes the token using the get_student_from_token(token: str) function: def get_student_from_token(token): payload = jwt.decode(token, SECRET_KEY, algorithms = [ALGORITHM]) expiry = payload.get('expiry') if datetime.utcnow() >= datetime.strptime(expiry, '%Y-%m-%d %H:%M:%S.%f'): # Compares the expiry date to the current date based on UCT return \"Token Expired\" else: return payload.get('details') # Returns the details as a dictionary of the name, email and UID This means that an expired or invalid token will immediately be rejected but a valid and correct token will be allowed. The app then performs all of its functions based on this data, allowing the app to extract the user's notes based on the OWNER_EMAIL property of each file, ensuring the privacy of user data and maintains the user experience. If the app returns a 401 error due to a bad token, the frontend intercepts this error and redirects the user to a login/sign-up page, as shown in the code: @Injectable() export class ErrorInterceptor implements HttpInterceptor { constructor(private router: Router, private route: ActivatedRoute) {} getChildRoute(route: ActivatedRoute): ActivatedRoute { while (route.firstChild) { route = route.firstChild; } return route; } intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> { const modifiedRequest = request.clone({ // Clones any incoming requests headers: request.headers.set('X-Requested-With', 'XMLHttpRequest'), withCredentials: true }); return next.handle(modifiedRequest).pipe( tap(() => {}, (err: any) => { if (err instanceof HttpErrorResponse) { // Checks if we have received an error if (err.status != 401 ) { return; } this.router.navigate(['/login']); // Prevents the request from going through and redirects to login page instead } })); } } This all ensures that the user can use the app easily, as they do not have to specify their ID when trying to use the app's functions whilst also preventing bad actors from accessing user data without protections. There is one exception to each API call having a token requirements. This is the cloud_check() function and is used by me to check if the API is responding to API calls. It is a simple get API call: @app.get(\"/api/cloud_check\") async def cloud_check(): return True And was initially used by my service provider to notify me if my API goes down. This is the only potential vulnerability evident to me, and is more dependent on my service provider's (Linode) protection to IPv6 & IPv4 calls to the server. When calling the method, it should return the following page:","title":"Backend"},{"location":"Developer%20Talk/Backend/#data-structures","text":"All of the data sent from the frontend was sent in the form of JSON. To allow our backend to interpret this, we used custom BaseModels for each POST & GET call. For example, if our frontend called a login function such as: this.http.post(this.URL + \"/check_student_login\", {email: \"example@example.com\", username: \"example\", password: \"example\"}).subscribe((res: any) => { Where, email , username and password are the JSON parameters, then our backend model would look like: from pydantic import BaseModel # Module to create the models class PostLoginCheckStudentModel(BaseModel): email: str username: str password: str And the API would receive the call like so: @app.post(\"/api/check_student_login\") async def check_student_login_post(user: PostLoginCheckStudentModel): return check_student_login(user.email, user.password) # Calls a function on the backend These Data Structures are repeated throughout the API and are paramount to our data manipulation methods.","title":"Data Structures"},{"location":"Developer%20Talk/Backend/#encryption","text":"Firstly, all passwords are encrypted before being stored in the backend. They are encrypted using Passlib's CryptContext module with 'bcrypt' as the schema. The password is encrypted with the following code: from pydantic import BaseModel # Import module pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") # Identify the schema used def hash_password(password): # Take a plaintext password & convert it to ciphertext return pwd_context.hash(password) This will encrypt our password. It is extremely secure as each password is non-reversible. This results in the same input string having a variable output hash as the starting 'salt' used by the algorithm will be different. For example, an input password of 1234 could result in: - $2b$12$zProG7RawgHpdXZ9RfxYZ.pcwZy4N29C6mRzBb8yAFvoHc5TSSyZC - $2b$12$0DPNbWZDAX5fJl4pyBHnIuWiLk.2w/rxU/MnuKFznmjouUMjFxW5. - $2b$12$U6PDFiGrqooLxsnHJ7X9gehpzH3tLiI./BH8oj3HejMSyZvGHPneC - $2b$12$YJK4L0S8pcFKokWUYqf1VuDtjxy.KptvvBN9VTJIvTPTuwc36KwAe - $2b$12$MWwHq8PHskJqF2EoGOI60..J92SVyjD5FHVc4Ugbv7ZnD10Wso6yO - $2b$12$r5qvt.4ik//TSFaVWxWZ3uFGdmUXJL35.FXeeb2uDiWSQSZYQWv0i With there being an almost infinite number of potential passwords based on the starting 'salt'. To verify the value of our password, we do not reverse the hash. This is because reversing the hash is impossible. Instead, we use an inbuilt function that compares the plain-text to the hashed cipher-text. This functionality is used when authenticating a user during login and is done like such: from pydantic import BaseModel # Import module pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") # Identify the schema used def verify_password(unhashed, hashed): return pwd_context.verify(unhashed, hashed) # Returns a boolean This function compares the original 'salt' and 'work factor' (Number of encryption iterations) and calculates whether the hash could have been derived from this input. If the algorithm deems it possible, then a boolean value of True is returned, otherwise the function returns False .","title":"Encryption"},{"location":"Developer%20Talk/Backend/#tokens","text":"When the frontend needs to make any request to the backend, it needs to provide a token. This token is valid for 7 days and stores the name , email and id of the user (student) that is currently logged in. When a user attempts to login, the details they input are checked against our database. If the email and password inputted align with an email and password from the database, a token is created and sent to the fronted. The token is created using the code: def get_user_token(student: Student): to_encode = { 'details' : {'name': student.name, 'email': student.email, 'id': student.id}, 'expiry' : str(datetime.utcnow() + timedelta(minutes = ACCESS_TOKEN_EXPIRE_MINUTES)) } return jwt.encode(to_encode, SECRET_KEY, algorithm = ALGORITHM) Where SECRET_KEY is a 256-bit custom code that is used for encryption and the algorithm is HS256. This token is then stored in the frontend. As a result of this, the user will not have to log in to the website on every occurrence of accessing the website. The fronted injects this token into every request as shown by the code: @Injectable() export class CookieInterceptor implements HttpInterceptor { private platformId = inject(PLATFORM_ID); intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> { // Intercepts an incoming request let token: string | undefined; if (isPlatformBrowser(this.platformId)) { token = document.cookie.split(\"; \").find((row) => row.startsWith(\"token=\"))?.split(\"=\")[1]; } // Extracts the token from the web-browser const modifiedRequest = request.clone({ withCredentials: true, setHeaders: token ? { 'token': token } : {} // Adds the token to the request }); return next.handle(modifiedRequest); // Sends the request to the API } } Once the backend receives this token, it then verifies it in every single function before even executing the intended request of the method call. This is done through the code: @app.post(\"/api/function_name\") async def post_delete_user(request: Request): token_res = validate_student(request.headers.get('token')) # Runs a backend function to validate the token by extracting the user details and checking the expiry of the token if token_res == False: return JSONResponse(status_code=401, content={\"message\": \"Invalid token\"}) # Prevents any functions if the token is invalid else: # Execute the intended code here To validate the token, the code firsts calls the function validate_student() : def validate_student(token): try: res = get_student_from_token(token) if res == \"Token Expired\": # Checks if the token is past its expiry date return False else: # Returns details in the form of a list return [res['name'], res['email'], res['id']] # If the token is invalid, return False except InvalidTokenError: return False # If the token cannot be decoded, return False except InvalidSignatureError: # Checks if the user has tried to use token injection, resulting in an invalid token return False To get the res variable, our code then decodes the token using the get_student_from_token(token: str) function: def get_student_from_token(token): payload = jwt.decode(token, SECRET_KEY, algorithms = [ALGORITHM]) expiry = payload.get('expiry') if datetime.utcnow() >= datetime.strptime(expiry, '%Y-%m-%d %H:%M:%S.%f'): # Compares the expiry date to the current date based on UCT return \"Token Expired\" else: return payload.get('details') # Returns the details as a dictionary of the name, email and UID This means that an expired or invalid token will immediately be rejected but a valid and correct token will be allowed. The app then performs all of its functions based on this data, allowing the app to extract the user's notes based on the OWNER_EMAIL property of each file, ensuring the privacy of user data and maintains the user experience. If the app returns a 401 error due to a bad token, the frontend intercepts this error and redirects the user to a login/sign-up page, as shown in the code: @Injectable() export class ErrorInterceptor implements HttpInterceptor { constructor(private router: Router, private route: ActivatedRoute) {} getChildRoute(route: ActivatedRoute): ActivatedRoute { while (route.firstChild) { route = route.firstChild; } return route; } intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> { const modifiedRequest = request.clone({ // Clones any incoming requests headers: request.headers.set('X-Requested-With', 'XMLHttpRequest'), withCredentials: true }); return next.handle(modifiedRequest).pipe( tap(() => {}, (err: any) => { if (err instanceof HttpErrorResponse) { // Checks if we have received an error if (err.status != 401 ) { return; } this.router.navigate(['/login']); // Prevents the request from going through and redirects to login page instead } })); } } This all ensures that the user can use the app easily, as they do not have to specify their ID when trying to use the app's functions whilst also preventing bad actors from accessing user data without protections. There is one exception to each API call having a token requirements. This is the cloud_check() function and is used by me to check if the API is responding to API calls. It is a simple get API call: @app.get(\"/api/cloud_check\") async def cloud_check(): return True And was initially used by my service provider to notify me if my API goes down. This is the only potential vulnerability evident to me, and is more dependent on my service provider's (Linode) protection to IPv6 & IPv4 calls to the server. When calling the method, it should return the following page:","title":"Tokens"}]}